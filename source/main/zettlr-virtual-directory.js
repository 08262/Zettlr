/**
 * @ignore
 * BEGIN HEADER
 *
 * Contains:        ZettlrVirtualDirectory
 * CVM-Role:        Model
 * Maintainer:      Hendrik Erz
 * License:         GNU GPL v3
 *
 * Description:     Creates a virtual directory (for manually sorting files)
 *
 *                  How it works:
 *                  1. Always holds a pointer to its "real" directory
 *                  2. On every read and write, the realDirectories are refreshed
 *                  3. Add and remove cause writes, read only once (constructor)
 *
 * END HEADER
 */

 const path = require('path');

 // Include helpers
 const { hash, sort } = require('../common/zettlr-helpers.js');

/**
 * Manages one single virtual directory containing manually added files. This
 * file is _NOT_ generated by ZettlrDir itself, but a helper function located
 * in common/zettlr-directory-helpers.js. This way, it's possible to add as many directory
 * class as one likes (virtual directories and filters are one possibility. Also
 * thinkable would be virtual project directories as well, or weblink directories.)
 */
class ZettlrVirtualDirectory
{
    constructor(dir, vd, model)
    {
         this.parent         = dir;
         this.path           = model.getDatabase();
         this.name           = vd.name;
         this.hash           = hash(this.path + this.name); // Path can be the same for multiple virtual dirs, therefore include name!
         this.children       = [];
         this.attachments    = [];
         this.type           = 'virtual-directory';
         this.sorting        = 'name-up';
         this._model         = model; // Handles persistancy of all these directories on disk (e.g. .ztr-virtual-directories- files)

         // Read in children from file
         this.init(vd.files);
    }

    /**
     * Initially read all files present in the vd object
     * @param  {Array} fileArray An array of relative paths.
     */
    init(fileArray)
    {
        for(let file of fileArray) {
            let f = this.parent.findFile({ 'path': this._makeAbsolute(file) });
            // Don't remove files from array if they aren't found.
            if(f != null) {
                this.children.push(f);
                f.addVD(this);
            }
        }
    }

    shutdown()
    {
        // The ZettlrFiles will shutdown when their real parent shuts down.
        // The model we may check, whether or not there were changes.
        let arr = this._model.get(this.name);
        let found = null;
        if(arr) {
            arr = arr.files;
            for(let f of arr) {
                if(!this.children.find((elem) => { return elem.path == this._makeAbsolute(f); })) {
                    // At least one file has changed -> Update everything, flush to disk and exit loop
                    this._updateModel();
                    this._model.flush();
                    break;
                }
            }
        }
    }

    handleEvent(p, e)
    {
        // TODO: Needs to listen for unlink-events of files and check all children
        // if they're still there!
    }

    findDir(obj)
    {
        // Return this, if hashes match
        if(obj.hasOwnProperty('hash') && obj.hash == this.hash) {
            return this;
        }

        return null;
    }

    findFile(obj)
    {
        let prop;

        if(obj.hasOwnProperty('path') && obj.path != null) {
            prop = 'path';
        } else if(obj.hasOwnProperty('hash') && obj.hash != null) {
            prop = 'hash';
        } else {
            throw new DirectoryError("Cannot search file. Neither path nor hash given.");
        }

        // Traverse the children
        for(let c of this.children) {
            let file = c.findFile(obj);
            if(file != null) {
                // Found it
                return file;
            }
        }

        // Not found
        return null;
    }

    findExact(term)
    {
        for(let c of this.children) {
            let file = c.findExact(term);
            if(file != null) {
                return file;
            }
        }

        return null;
    }

    get(hash)
    {
        for(let c of this.children) {
            let cnt = c.get(hash);
            if(cnt != null) {
                // Got it -> return.
                return cnt;
            }
        }

        return null;
    }

    remove(obj = this)
    {
        if(obj === this) {
            // Remove this directory
            this.detach();
        } else {
            // Remove a file
            let index = this.children.indexOf(obj);

            // Should (normally) always be true. Attention: Is never called by
            // the children, who have another parent!
            if(index > -1) {
                this.children.splice(index, 1);
                this._updateModel();
                obj.removeVD(this);
            } else {
                // Fail gracefully
                return false;
            }
        }

        return true;
    }

    move(newpath, name = null)
    {
        // Name must be given for virtual directories.
        if(!name) {
            return this;
        }

        // Update model!
        let oldname = this.name
        this.name = name; // No need to detach on rename
        this._updateModel(oldname);

        // But what we want to do is have the parent re-sort its children
        this.parent.sort();
        this.hash = hash(this.path + this.name);
        // Chainability
        return this;
    }

    attach(newchild)
    {
        // Only add files, prevent duplicates and make sure the file is inside the parent directory.
        if(!newchild.isFile() || this.contains(newchild) || !this.parent.contains(newchild)) {
            if(!this.parent.contains(newchild)) {
                this.parent.notifyChange(`Cannot add file to virtual directory ${this.name}, it resides outside the containing directory.`);
            }
            return this;
        }

        this.children.push(newchild);
        this.children = sort(this.children, this.sorting);

        this._updateModel();
        newchild.addVD(this);

        return this;
    }

    detach()
    {
        this.parent.remove(this);
        this.parent = null;
        // Also remove from model by passing null as value argument
        this._model.set(this.name, null);
        for(let c of this.children) {
            c.removeVD(this);
        }
        return this;
    }

    toggleSorting(type='name-up')
    {

            if(ALLOW_SORTS.includes(type)) {
                this.sorting = type;
            } else if(type.indexOf('name') > -1) {
                if(this.sorting == 'name-up') {
                    this.sorting = 'name-down';
                } else {
                    this.sorting = 'name-up';
                }
            } else if(type.indexOf('time') > -1) {
                if(this.sorting == 'time-up') {
                    this.sorting = 'time-down';
                } else {
                    this.sorting = 'time-up';
                }
            } else {
                this.sorting = 'name-up';
            }

            this.children = sort(this.children, this.sorting);
            return this;
    }

    exists(p)
    {
        // VirtualDirectories must never act as if they were really containing something
        return null;
    }

    contains(obj)
    {
        if(!obj) {
            // In rare occasions, it can happen that there is no object given
            return false;
        }

        if(typeof obj === 'number') {
            // Same problem as in the find-methods. Only here I don't care anymore.
            // Simply assume a hash. Nothing else could be it.
            obj = { 'hash': obj };
        } else if(!obj.hasOwnProperty('hash')) {
            // Prevent errors.
            return false;
        }

        if(this.findDir({ 'hash': obj.hash }) !== null) {
            return true;
        } else if(this.findFile({ 'hash': obj.hash}) !== null) {
            // Try a file
            return true;
        }

        return false;
    }

    hasChild(obj)
    {
        // VirtualDirectories don't really contain children.
        return null;
    }

    sort()
    {
        this.children = sort(this.children, this.sorting);
        return this;
    }

    getHash()
    {
        return this.hash;
    }

    getPath()
    {
        // VirtualDirectories don't have a specific path
        return '';
    }

    getName()
    {
        return this.name;
    }

    isDirectory()
    {
        // In this very instance, we may respectfully pretend to be a directory
        return true;
    }

    /**
     * Dummy function for recursive use. Always returns true.
     * @return {Boolean} Returns true.
     */
    isVirtualDirectory() { return true; }

    isFile()
    {
        return false;
    }

    isRoot()
    {
        // VirtualDirectories are never root
        return false;
    }

    isScope()
    {
        // Must return false, because we're not a real directory, the real parent
        // should handle this case.
        return false;
    }

    /**
     *   HELPER FUNCTIONS
     */

    update()
    {
        // This function is called whenever an included file changes its path to
        // make sure files that have been moved outside will be removed.
        for(let c of this.children) {
            if(!this.parent.contains(c)) {
                // Remove
                this.children.splice(this.children.indexOf(c), 1);
            }
        }

        // Update
        this._updateModel();
    }

     /**
      * Write changes to the model
      * @param  {String} [rowname=this.name] If the name has changed, this is the possibility to give the correct one.
      */
    _updateModel(rowname = this.name)
    {
        let arr = [];
        for(let c of this.children) {
            if(c.isFile() && this.parent.contains(c)) { // Doublecheck if this is still the case.
                arr.push(this._makeRelative(c.path));
            }
        }

        let nData = { 'name': this.name, 'files': arr }

        this._model.set(rowname, nData);
    }

    /**
     * Makes a path relative (extracts the root directory's path from interval)
     * @param  {String} p The path to be returned relative
     * @return {String}   The relative path
     */
    _makeRelative(p)
    {
        if(this._isAbsolute(p)) {
            return p.replace(this._getRootPath(), '');
        }

        return p;
    }

    /**
     * Returns an absolute path (i.e. a path containing the complete path to file)
     * @param  {String} p The path to be returned absolute
     * @return {String}   The absolute path.
     */
    _makeAbsolute(p)
    {
        if(!this._isAbsolute(p)) {
            return path.join(this._getRootPath(), p);
        }

        return p;
    }

    /**
     * Whether or not the path is absolute (i.e. contains the root string's path)
     * @param  {String}  p The path to checked
     * @return {Boolean}   True, if the path contains the root directory's path
     */
    _isAbsolute(p)
    {
        if(p.indexOf(this._getRootPath()) == 0) {
            return true;
        }

        return false;
    }

    /**
     * Returns the containing ZettlrDir's path
     * @return {String} The containing directory's path
     */
    _getRootPath()
    {
        return this.parent.path;
    }
}

module.exports = ZettlrVirtualDirectory
